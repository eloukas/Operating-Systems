#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-
Ονοματεπώνυμο					ΑΕΜ		E-mail

Σωτήριος-Παναγιώτης Χύτας		2012	schytas@uth.gr
Κλάιντι Μποντούρρι 				2020	kbontourri@uth.gr
Ελευθέριος-Παναγιώτης Λούκας 	2029	eloukas@uth.gr

#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-

Όσον αφορά τα configs:
	Υπάρχουν 3 configs με τα εξής ονόματα :
	1)interactive
	2)non_interactive
	3)starvation_exp_burst
	
	Όλα τους είναι με μη αμελητέο χρόνο εκτέλεσης και χρησιμοποιήθηκαν για το όλο report,
	όπως θα διαπιστώσετε και παρακάτω.

Όσον αφορά το Goodness:
	Παρατηρούμε πάρα πολύ υψηλές τιμές στο goodness μιας διεργασίας, όταν αυτή
	μπαίνει για πρώτη φορά στο Run Queue.
	Αυτό γίνεται για τον εξής λόγο:
	Το πρώτο κλάσμα της goodness ισούται με ~1 
	Στο δεύτερο κλάσμα τώρα, ο αριθμητής ισούται με έναν πολύ μεγάλο αριθμό
	ενώ ο παρονομαστής είναι 1.Αυτό γίνεται διότι η διεργασία *μόλις* μπήκε στο Queue,
	συνεπώς WaitingInRQ(k) = 0.
	
Όσον αφορά το expected burst:
	Υπάρχει περίπτωση λιμοκτονίας με τη χρήση μόνο του exp_burst.
	Για παράδειγμα, υπάρχει πιθανότητα να υπάρχουν διεργασίες που περιμένουν στην ουρά
	αλλά ποτέ δεν εκτελούνται διότι μπορεί να έρχονται άλλες νέες συνεχώς ή άλλες να 'παίρνουν' τη θέση της
	λόγω μικρότερης τιμής του expected burst.
	Αυτό είναι μια αδυναμία του SJF με expected burst όπου ζητείται να σχολιαστεί από την εκφώνηση
	και επίσης επαληθεύεται άμα τρέξουμε το πρόγραμμα με ορισμα το starvation_exp_burst config.
	
	Ακόμη, σε περίπτωση πολλών διεργασιών που πραγματοποιούν ~μηδενικό I/O (non-interactive διεργασίες)
	ο SJF μοιάζει σαν Round Robin(RR) .
	Το παραπάνω μπορεί να επιβεβαιωθεί τρέχοντας το πρόγραμμα με όρισμα το non_interactive config.
	
Όσον αφορά goodness έναντι expected burst:
	Η χρήση του goodness είναι η λύση στο παραπάνω παράδειγμα λιμοκτονίας (του exp_burst) καθώς πλέον παίζει ρόλο
	και το πόσο πολύ περιμένει μια διεργασία στο RQ (waiting_in_rq)

Γενικότερα για τον αλγόριθμο χρονοδρομόλογησς SJF : 
	Εύκολος 'άπληστος' αλγόριθμος για να υλοποιηθεί. Μπορεί να είναι pre-emptive και non-preemptive.
	Βέβαια, υπάρχουν ελαττώματα όπως το ότι μπορεί να προκαλέσει λιμοκτονία ή αδικία(μονοπώλειο διεργασιών πχ)
	Κάτι άλλο πιο σημαντικό είναι ότι υπάρχει η απαίτηση να ξέρουμε πότε μια διεργασία θα τελειώσει, γεγονός πρακτικά αδύνατο στις περισσότερες περιπτώσεις.
	Όμως, υπάρχουν σχετικά αποτελεσματικοί τρόποι για να προσεγγίσουμε και να κάνουμε 'μαντεψιές' για αυτούς τους χρόνους(πχ μέσος όρος προηγούμενων χρόνων εκτελέσεων)
	
	Τα παραπάνω τον αξιολογούν ως έναν αρκετά καλό αλγόριθμο για *long-term ειδικά* CPU scheduling με μεγάλο throughput ο οποίος ελαχιστοποιεί
	για καθε διεργασία το μέσο όρο αναμονής της, έχοντας όντως αποτελέσματα.
	
	
	


############################################################################
## Comments ##
Με βαση το expected_burst
1) Λιμοκτονία σε περιπτωση που σε καθε κυκλο ερχεται και νεα διεργασια!

2) Εξαρτάται σε ποιόν κύκλο μηχανής θα έρθει η κάθε διεργασία. Παράδειγμα αν έρθει
η 1η στα 10ms και η 2η στα 30ms τότε οι εναλλαγές θα γίνονται ανά 2 (30ms-10ms=20ms
με 10ms κβάντο 20ms/10ms=2) 

3) Λειτουργεί σαν RR σε περίπτωση που σκάσουν πολλές non-interactive ταυτόχρονα!

4) Σε περίπτωση pre-emptive πάντα θα τρέχει αυτή που μόλις ήρθε!

Με βαση το goodness
1) Σε non-interactive διεργασιες δουλευει σαν RR λόγο δεν πρόκειτε να πάρει την 
cpu η ιδια διεργάσια που έτρεχε στον προηγούμενο κβάντο (έχει τεραστιο goodness
λόγο του δικου της waiting_in_rq =0)

2) Δεν υπάρχει περίπτωση λιμοκτονίας λόγο ότι το waiting_in_rq σε αυτήν που
"λιμοκτονεί" θα αυξηθεί οπότε το goodness θα μεγαλωσει

3) Goodness λειτουργεί "δίκαια" σε περίπτωση που γίνονται πόλλα interrupts λόγο οτι
πάντα επιλέγει διεργασία βάση πόσο χρόνο θα τρέξει μια διεργασία και πόσο αδικημένη
είναι λόγο waiting_in_rq

Οπότε στο report:

1) Πλεονεκτηματα/Μειονεκτηματα απο expected_burst,goodness
2) Corner cases συμπεριφορα
3) Επισης να παίξουμε λίγο με το κβάντο και πως αλληλεπιδρά!
4) Διαλεξη scheduling σελ 25 το Σχημα, πρακτικα ειναι το goodness (να βγαλουμε
ενα παρομοιο)
5) Να φτιαξουμε τα prints, ωστε να βγαζουμε χρονο ολοκληρωσης κλπ κλπ
